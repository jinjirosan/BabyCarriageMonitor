#!/usr/bin/env python
#
# Maintainer 	: JinjiroSan
# Version	: vegasmonitor 2.0 - initialstate_streamer 

import os
import sys
import time
import threading
import traceback
import glob
from gps import * 
from subprocess import PIPE, Popen
from envirophat import light, weather, motion, analog
from ISStreamer.Streamer import Streamer
from geopy.geocoders import Nominatim
from geopy.exc import GeocoderTimedOut
from bisect import bisect_left                                  # for chance of rain from pressure value

geolocator=Nominatim()
gpsd = gps(mode=WATCH_ENABLE)

## designate bucket name and individual access_key, dataset will append to existing bucket
streamer=Streamer(bucket_name="stokkezeroGPSDATA",bucket_key="<insert bucket key>", access_key="<insert API key>")

## modprobes for ds18b20 temp sensor
os.system('modprobe w1-gpio')
os.system('modprobe w1-therm')

## ds18b20 temp sensor ID's
#base_dir_feet = '/sys/bus/w1/devices/28-031655b78bff/w1_slave'
#base_dir_front = '/sys/bus/w1/devices/28-041658f324ff/w1_slave'
base_dir_headliner = '/sys/bus/w1/devices/28-041658f014ff/w1_slave'

raintable = {0:80, 994:70, 998:60, 1002:50, 1007:40, 1011:30, 1016:20, 1020:10}

def get_cpu_temperature():
    process = Popen(['vcgencmd', 'measure_temp'], stdout=PIPE)
    output, _error = process.communicate()
    return float(output[output.index('=') + 1:output.rindex("'")])

def read_enviro_temp():
    temp_raw = round(weather.temperature(),2)
    temp_cpu = get_cpu_temperature()
    temp_calibrated = temp_raw - ((temp_cpu - temp_raw)/1.9)
    return temp_calibrated
#     return round(weather.temperature(),2)

def read_enviro_heading():
    corr_heading = (motion.heading() - 10) % 360        ## verify North correction , 10 is a placeholder
    e_heading = corr_heading
    return e_heading

def read_enviro_accelerometer():
#    x, y, z = round(motion.accelerometer(),2)
    axes = motion.accelerometer()
    return axes

def read_enviro_pressure():
    e_pressure = round(weather.pressure(),2)
    return e_pressure * 0.01

def rainchance(pressure):
    return raintable[max({ k: raintable[k] for k in raintable if k < read_enviro_pressure()})]

def read_enviro_light():
    e_light = light.light()
    return e_light

def read_temp_raw_headliner():
    f_headliner = open(base_dir_headliner, 'r')
    lines_headliner = f_headliner.readlines()
    f_headliner.close()
    return lines_headliner

def read_temp_headliner():
    lines_headliner = read_temp_raw_headliner()
    while lines_headliner[0].strip()[-3:] != 'YES':
        time.sleep(0.2)
        lines_headliner = read_temp_raw_headliner()
    equals_pos = lines_headliner[1].find('t=')
    if equals_pos != -1:
        temp_string_headliner = lines_headliner[1][equals_pos+2:]
        temp_c_headliner = float(temp_string_headliner) / 1000.0
        return temp_c_headliner

##  thread to collect gpsd info
class GpsPoller(threading.Thread):

 def __init__(self):
    threading.Thread.__init__(self)
    global gpsd                         ## bring gpsd in scope
    self.current_value = None
    self.running = True                 ## setting the thread running to true

 def run(self):
    global gpsd
    while gpsd.running:
     gpsd.next()
    sleep(10)

try:
    while True:
        gpsd.next()
        os.system('clear')
        temp_cpu = get_cpu_temperature()
        temp_raw = round(weather.temperature(),2)
        temp = round(read_enviro_temp(),2)
        heading = read_enviro_heading()
        axes = read_enviro_accelerometer()
        pressure = round(read_enviro_pressure(),1)
        rainchancepercentage = rainchance(pressure)
        e_light = read_enviro_light()
        temp_c_headliner = round(read_temp_headliner(),2)
        temp_f_headliner = temp_c_headliner * 9.0 / 5.0 + 32.0
        x = round(axes[0],3)
        y = round(axes[1],3)
        z = round(axes[2],3)

        print				## "print" section to be removed for production
        print ' GPS reading'
        print '----------------------------------------'
        print 'latitude ' , gpsd.fix.latitude
        print 'longitude ' , gpsd.fix.longitude
        print 'time utc ' , gpsd.utc,' + ', gpsd.fix.time
        print 'altitude (m)' , gpsd.fix.altitude
        print 'eps ' , gpsd.fix.eps
        print 'epx ' , gpsd.fix.epx
        print 'epv ' , gpsd.fix.epv
        print 'ept ' , gpsd.fix.ept
        print 'speed (m/s) ' , gpsd.fix.speed
        print 'speed (km/h) ' , gpsd.fix.speed*3.6
        print 'climb ' , gpsd.fix.climb
        print 'track ' , gpsd.fix.track
        print 'mode ' , gpsd.fix.mode
        print
        print ' environment reading'
        print '----------------------------------------'
        print 'temp (cpu)' , temp_cpu, 'c'
        print 'temp (uncalibrated) ', temp_raw, 'c'
        print 'temp (calibrated) ', temp, 'c'
        print 'temp (ds18b20) ', temp_c_headliner, 'c'
        print 'pressure ', pressure, 'hPa'
        print 'chance of rain ', rainchance, '%'
        print 'light level ', light
        print 'heading ' , heading
        print 'stance ' , axes
        print 'x (roll) ', x
        print 'y (pitch) ', y
        print 'z (yaw) ', z
        print
        print ' Satellites reading'
        print '----------------------------------------'
        print 'sats ' , gpsd.satellites

        ## turn latitude and longitude into string
        coordinates = str(gpsd.fix.latitude) + "," + str(gpsd.fix.longitude)

        ## data streamers to initialstate
        streamer.log("Coordinates",coordinates)
        streamer.log("Reported Time",gpsd.utc,)
        streamer.log("Altitude (m)",gpsd.fix.altitude)
        streamer.log("Climb (m/s)",gpsd.fix.climb)
        streamer.log("Lat Error",gpsd.fix.epy)
        streamer.log("Long Error",gpsd.fix.epx)
        streamer.log("Timestamp Error",gpsd.fix.ept)
        streamer.log("Speed (m/s)",gpsd.fix.speed)
        streamer.log("Speed Error",gpsd.fix.eps)

        location=geolocator.reverse(coordinates,timeout=10) ## reverse geocode coordinates
        streamer.log("Location",location.address)

        streamer.log("headliner temperature(C)", temp_c_headliner)
        streamer.log("headliner temperature(F)", temp_f_headliner)
        streamer.log("rpi temperature(C)", temp_cpu)
        streamer.log("enviro temperature(C) uncalibrated", temp_raw)
        streamer.log("enviro temperature(C) calibrated", temp)
        streamer.log("headliner temperature(C)", temp_c_headliner)
        streamer.log("enviro pressure(hPa)" , pressure)
        streamer.log("chance of rain(%)" , rainchancepercentage)
        streamer.log("enviro light intensity" , light)
        streamer.log("enviro heading" , heading)
        streamer.log("enviro accelerometer 3-axis" , axes)
        streamer.log("enviro accelerometer X (roll)" , x)
        streamer.log("enviro accelerometer Y (pitch)" , y)
        streamer.log("enviro accelerometer Z (yaw)" , z)

	time.sleep(5)
        ## keep loop active even if streamer times out
except GeocoderTimedOut as e:
        streamer.log("msg","Geocoder Timeout")
        pass

## pressing CTRL-C or the system exits itself, print a message and close everything
except (KeyboardInterrupt, SystemExit):         # user interupt, CTRL-C
        print "\nKilling Thread..."
        streamer.close() 			# finish all streamer data
        gpsd.running = False
        gpsd.join() 				# clear threads
        print "Done.\nExiting."
        exit() 					# allllll done, nothn to see here :-)
#if __name__ == "__main__":
#    main()
